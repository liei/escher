%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <getopt.h>

typedef int simulation_t;
  //#include <simulation.h>



extern char yytext[];
extern int yylineno;
extern FILE *yyin;

 int main(int argc, char **argv);
int yyparse(void);
int yylex(void);
void yyerror(const char *str);

int iterations, steps, x_size, x_pos, y_size, y_pos, samples;
double *alpha = NULL, *beta = NULL;

//static simulation_t *yysim;

/* linked list implementation to parse the alpha/beta probs */
typedef struct l{
  double data;
  struct l *next;
  int length;
} list_node;

void assign_list(double **a,list_node *node);
void parse_config(simulation_t *sim, char *filename);

%}

%token T_ITERATIONS T_STEPS T_XSIZE T_XPOS T_YSIZE T_YPOS T_SAMPLES T_ALPHA T_BETA 

%union {
  int t_integer;
  double t_double;
  struct l  * t_node;
}

%token <t_integer> INTEGER
%token <t_double> DOUBLE

%type <t_node> list node
%type <t_integer> integer 

%%

assignment_list:    /*empty*/
               |    assignment_list assignment
               ;

assignment:         T_ITERATIONS  '=' integer       {iterations = $3;}
          |         T_STEPS '=' integer             {steps = $3;}
          |         T_XSIZE '=' integer             {x_size = $3;}
          |         T_XPOS  '=' integer             {x_pos = $3;}
          |         T_YSIZE '=' integer             {y_size = $3;}
          |         T_YPOS  '=' integer             {y_pos = $3;}
          |         T_SAMPLES '=' integer           {samples = $3;}
          |         T_ALPHA '=' '[' list ']'        {assign_list(&alpha,$4);}
          |         T_BETA '=' '[' list ']'         {assign_list(&beta,$4);}          
          ;

list:               node                            {$$ = $1;}
    |               node ',' list                   {$$ = $1;$$->next = $3;$$->length = $3->length + 1;}
    ;

node:             DOUBLE                            {$$ = malloc(sizeof(list_node));*$$ = (list_node){atof(yytext),NULL,1};}
    ;

integer:            INTEGER                         {$$ = atoi(yytext);}
       ;

%%

void yyerror(const char *str){
  fprintf(stderr,"error:%d - %s \n",yylineno,str);
}

int main(int argc, char **argv){
  
  char *simfile = NULL;

  int opt = 0;
  while((opt = getopt(argc,argv,"f:o:")) != -1){
    switch(opt){
    case -1: break;
    case 'f':
      simfile = optarg;
      break;
    case 'o':
      if(freopen(optarg,"w",stdout) == NULL){
	fprintf(stderr,"Couldn't write to output file: %s\n",optarg); 
        exit(EXIT_FAILURE);
      }
    default:
      break;
    }
  }
  if(optind < argc){
    simfile = argv[optind];
  }
  

  parse_config(NULL,simfile);

  fprintf(stdout,"iterations: %d\n",iterations);
  fprintf(stdout,"steps: %d\n",steps);
  fprintf(stdout,"x_size: %d\n",x_size);
  fprintf(stdout,"x_pos: %d\n",x_pos);
  fprintf(stdout,"y_size: %d\n",y_size);
  fprintf(stdout,"samples: %d\n",samples);
  fprintf(stdout,"alpha: ");
  for(int i = 0; i < steps; i++)
    fprintf(stdout,"%f, ",alpha[i]);
  fprintf(stdout,"\n");
  fprintf(stdout,"beta: ");
  if(beta != NULL){
    for(int i = 0; i < steps; i++)
      fprintf(stdout,"%f, ",beta[i]);
  }
  fprintf(stdout,"\n");

  return EXIT_SUCCESS;
}

void assign_list(double **array,list_node *node){
  steps = node->length;
  double *a = malloc(sizeof(double) * node->length);
  list_node *old;
  for(int i = 0;node != NULL; i++){
    a[i] = node->data;
    node = (old = node)->next;
    free(old);
  }
  *array = a;
}

void parse_config(simulation_t *sim, char *filename){
  if((yyin = fopen(filename,"r")) == NULL){
    fprintf(stderr,"Couldn't read simulation file: %s.\n",filename);
    exit(EXIT_FAILURE);
  }
  yyparse();
}
